# Парадигмы программирования и языки парадигм
## Урок 6. Парадигмы программирования на практике.
**Цели семинара**
- Понять основные отличия между декларативной и императивной парадигмами
- Начать решать задачи в рамках одной выбранной парадигмы
### Домашнее задание
Бинарный поиск

● Контекст <br>
Предположим, что мы хотим найти элемент в массиве (получить
его индекс). Мы можем это сделать просто перебрав все элементы.
Но что, если массив уже отсортирован? В этом случае можно
использовать бинарный поиск. Принцип прост: сначала берём
элемент находящийся посередине и сравниваем с тем, который мы
хотим найти. Если центральный элемент больше нашего,
рассматриваем массив слева от центрального, а если больше -
справа и повторяем так до тех пор, пока не найдем наш элемент.

![](../assets/hw-6-0.jpg)

● Ваша задача <br>
Написать программу на любом языке в любой парадигме для
бинарного поиска. На вход подаётся целочисленный массив и
число. На выходе - индекс элемента или -1, в случае если искомого
элемента нет в массиве.


### Решение задания

Бинарный поиск — тип поискового алгоритма, который последовательно делит пополам <br>
заранее отсортированный массив данных, чтобы обнаружить нужный элемент.  <br>
Этот алгоритм значительно эффективнее линейного поиска для больших массивов,  <br>
так как сокращает количество проверок путём деления массива на две части на каждой итерации. <br> 
Бинарный поиск для поиска элемента в отсортированном массиве работает за O(log n) времени, что значительно быстрее, <br> 
чем линейный поиск, который работает за O(n) времени. <br>

1. Можно реализовать бинарный поиск на python в декларативной парадигме, в файле [61.py](61.py), используя рекурсию для определения индекса искомого элемента.
   
Функция binary_search принимает отсортированный массив arr и целевой элемент target. Возвращает индекс элемента target в массиве arr, если он найден, иначе возвращает -1.
Функция search рекурсивно выполняет бинарный поиск. Если low больше high, значит элемент не найден, и возвращается -1.
Вычисляется средний индекс mid. Если элемент в mid равен target, возвращается mid. Если элемент в mid меньше target, рекурсивно ищется в правой половине массива.
Если элемент в mid больше target, рекурсивно ищется в левой половине массива.

![](../assets/hw-6-1.jpg)

2. Бинарный поиск в императивной парадигме можно реализовать с использованием цикла для определения индекса искомого элемента вместо рекурсии, в файле [62.py](62.py)

Для инициализации low устанавливается в начало массива (индекс 0). high устанавливается в конец массива (индекс len(arr) - 1).
Цикл while продолжается до тех пор, пока low меньше или равен high.
Вычисляется средний индекс mid. Если элемент в mid равен target, возвращается mid. Если элемент в mid меньше target, low устанавливается на mid + 1, чтобы искать в правой половине.
Если элемент в mid больше target, high устанавливается на mid - 1, чтобы искать в левой половине.
Если элемент не найден, возвращается -1.

![](../assets/hw-6-2.jpg)

<br><br><hr><br>

[Содержание программы README.md](../README.md)

<br><br>